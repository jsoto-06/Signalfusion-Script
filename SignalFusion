//@version=6
// SignalFusion Ultimate - Indicador Optimizado v3.0
// Combina lo mejor de ambos scripts con doble confirmación
// Resistencias/Soportes dinámicos mejorados
// Modos adaptativos por timeframe

indicator('SignalFusion Ultimate v3.0', overlay=true, max_lines_count=500, max_labels_count=500)

// ========================= INPUTS PRINCIPALES =========================
// Modo de Trading con adaptación por timeframe
mode = input.string('Standard', 'Modo Trading', options=['Conservative', 'Standard', 'Aggressive'], 
  tooltip='Conservative: Menos señales, más seguras. Standard: Balance. Aggressive: Más señales, mayor riesgo')

// Configuración visual
show_signals = input.bool(true, 'Mostrar Señales', group='Visual')
show_sl_tp_markers = input.bool(true, 'Mostrar SL/TP Labels', group='Visual')
show_sl_tp_lines = input.bool(true, 'Mostrar Líneas SL/TP', group='Visual')
show_debug_info = input.bool(true, 'Mostrar Info Debug', group='Visual')
show_sr_lines = input.bool(true, 'Mostrar Líneas S/R', group='Visual')  // Nueva opción para mostrar/ocultar S/R

// Doble confirmación
require_double_confirmation = input.bool(true, 'Requerir Doble Confirmación', group='Señales',
  tooltip='Evita señales contradictorias en la misma vela')
confirmation_bars = input.int(2, 'Barras para Confirmación', minval=1, maxval=5, group='Señales')

// ========================= TIMEFRAME DETECTION =========================
_tf = timeframe.period
is_1m = _tf == '1' or _tf == '1S'
is_5m = _tf == '5'
is_15m = _tf == '15'
is_30m = _tf == '30'
is_45m = _tf == '45'
is_1h = _tf == '60' or str.upper(_tf) == '1H'
is_2h = _tf == '120' or str.upper(_tf) == '2H'
is_4h = _tf == '240' or str.upper(_tf) == '4H'

// ========================= INPUTS ADAPTATIVOS =========================
// Inputs base (se ajustarán después según timeframe)
rsi_len = input.int(14, 'RSI Length', minval=5, maxval=30, group='Indicadores')
bb_length = input.int(20, 'Bollinger Length', minval=10, maxval=50, group='Indicadores')
bb_stddev = input.float(2.0, 'BB Desviación', step=0.1, minval=1.5, maxval=3.0, group='Indicadores')
ema_fast_len = input.int(12, 'EMA Rápida', minval=5, group='EMAs')
ema_slow_len = input.int(26, 'EMA Lenta', minval=10, group='EMAs')
ema_mid_len = input.int(50, 'EMA Media', minval=20, group='EMAs')
ema_trend_len = input.int(200, 'EMA Tendencia', minval=50, group='EMAs')

// ========================= ADAPTIVE ADJUSTMENTS =========================
// Ajustar parámetros según timeframe
rsi_len_adapted = is_1m ? 8 : is_5m ? 12 : is_15m ? math.max(rsi_len, 14) : is_30m ? math.max(rsi_len, 14) : is_45m ? math.max(rsi_len, 16) : is_1h ? math.max(rsi_len, 18) : is_2h ? math.max(rsi_len, 21) : rsi_len

bb_length_adapted = is_1m ? math.max(bb_length-4, 16) : is_5m ? math.max(bb_length-2, 18) : is_15m ? bb_length : is_30m ? bb_length : is_45m ? bb_length+2 : is_1h ? bb_length+4 : is_2h ? bb_length+6 : bb_length

ema_fast_adapted = is_1m ? math.max(ema_fast_len-4, 8) : is_5m ? math.max(ema_fast_len-3, 9) : is_15m ? ema_fast_len : is_30m ? ema_fast_len+3 : is_45m ? ema_fast_len+6 : is_1h ? ema_fast_len+9 : is_2h ? ema_fast_len+14 : ema_fast_len

ema_slow_adapted = is_1m ? math.max(ema_slow_len-8, 18) : is_5m ? math.max(ema_slow_len-5, 21) : is_15m ? ema_slow_len : is_30m ? ema_slow_len+4 : is_45m ? ema_slow_len+9 : is_1h ? ema_slow_len+16 : is_2h ? ema_slow_len+24 : ema_slow_len

// MACD con valores fijos por defecto (luego se adaptarán)
macd_fast_input = input.int(12, 'MACD Rápido', group='MACD')
macd_slow_input = input.int(26, 'MACD Lento', group='MACD')
macd_signal = input.int(9, 'MACD Señal', group='MACD')

// Adaptar MACD según timeframe
macd_fast = is_1m ? math.max(macd_fast_input-2, 10) : is_5m ? macd_fast_input : macd_fast_input
macd_slow = is_1m ? math.max(macd_slow_input-4, 22) : is_5m ? macd_slow_input : macd_slow_input

// ========================= MODE ADJUSTMENTS BALANCEADOS =========================
// Umbrales base por timeframe - BALANCEADOS
base_long_threshold = is_1m ? 3.8 : is_5m ? 3.5 : is_15m ? 3.2 : is_30m ? 3.0 : is_45m ? 2.8 : is_1h ? 2.6 : is_2h ? 2.4 : 3.0
base_short_threshold = is_1m ? 3.8 : is_5m ? 3.5 : is_15m ? 3.2 : is_30m ? 3.0 : is_45m ? 2.8 : is_1h ? 2.6 : is_2h ? 2.4 : 3.0

// Balance de señales
signal_balance = input.string('Balanced', 'Balance de Señales', options=['Long Bias', 'Balanced', 'Short Bias'], group='Filtros', tooltip='Ajusta el balance entre señales long y short')

// Ajustes por modo con mejor balance
mode_mult = mode == 'Conservative' ? 1.3 : mode == 'Aggressive' ? 0.75 : 1.0

long_threshold = base_long_threshold * mode_mult
short_threshold = base_short_threshold * mode_mult

// Balance adicional según configuración
long_threshold := signal_balance == 'Long Bias' ? long_threshold * 0.9 : signal_balance == 'Short Bias' ? long_threshold * 1.1 : long_threshold
short_threshold := signal_balance == 'Long Bias' ? short_threshold * 1.1 : signal_balance == 'Short Bias' ? short_threshold * 0.9 : short_threshold

// ATR para SL/TP más conservador
base_atr_sl = is_1m ? 1.4 : is_5m ? 1.4 : is_15m ? 1.2 : is_30m ? 1.1 : is_45m ? 1.0 : is_1h ? 0.9 : is_2h ? 0.8 : 1.1
base_atr_tp = is_1m ? 2.4 : is_5m ? 2.4 : is_15m ? 2.0 : is_30m ? 1.9 : is_45m ? 1.8 : is_1h ? 1.7 : is_2h ? 1.6 : 2.0

atr_sl_mult = mode == 'Conservative' ? base_atr_sl * 1.2 : 
              mode == 'Aggressive' ? base_atr_sl * 0.85 : base_atr_sl
              
atr_tp_mult = mode == 'Conservative' ? base_atr_tp * 0.9 : 
              mode == 'Aggressive' ? base_atr_tp * 1.3 : base_atr_tp

// ========================= FILTROS =========================
use_time_filter = input.bool(false, 'Filtro de Horario', group='Filtros')
session_hours = input.session('0900-1600,1700-2000', 'Horario Trading', group='Filtros')  // Mejorado para múltiples sesiones
use_volume_filter = input.bool(false, 'Filtro de Volumen', group='Filtros')
volume_mult = input.float(1.2, 'Multiplicador Volumen', step=0.1, minval=0.5, maxval=3.0, group='Filtros')
volume_length = input.int(20, 'Longitud SMA Volumen', minval=5, maxval=50, group='Filtros')
use_volatility_filter = input.bool(false, 'Filtro Volatilidad', group='Filtros')
volatility_mult = input.float(1.1, 'Multiplicador Volatilidad', step=0.1, minval=0.8, maxval=2.0, group='Filtros')

// Filtros adicionales configurables
use_trend_filter = input.bool(false, 'Filtro de Tendencia Principal', group='Filtros')
min_atr_filter = input.bool(false, 'Filtro ATR Mínimo', group='Filtros')
min_atr_value = input.float(0.0001, 'ATR Mínimo', step=0.0001, minval=0.0001, group='Filtros')  // Validación con minval

// Nueva validación de parámetros
min_distance_ticks = math.max(input.float(30, 'Distancia Mínima (ticks)', minval=5, group='S/R'), 5.0)  // Validación con math.max

// ========================= SOPORTES/RESISTENCIAS MEJORADOS =========================
pivot_len = input.int(15, 'Pivot Length', minval=5, maxval=50, group='S/R')
max_lines = input.int(6, 'Máximo Líneas S/R', minval=2, maxval=15, group='S/R')
sr_strength_min = input.int(2, 'Toques Mínimos', minval=1, maxval=5, group='S/R')
sr_lookback = input.int(200, 'Lookback Toques', minval=50, maxval=500, group='S/R')
sr_tolerance = input.float(8.0, 'Tolerancia Toques (ticks)', minval=2.0, group='S/R')

// ========================= CÁLCULOS INDICADORES =========================
// RSI y su MA (usando valores adaptados)
rsi = ta.rsi(close, rsi_len_adapted)
rsi_ma = ta.sma(rsi, 7)

// Bandas de Bollinger (usando valores adaptados)
bb_middle = ta.sma(close, bb_length_adapted)
bb_upper = bb_middle + bb_stddev * ta.stdev(close, bb_length_adapted)
bb_lower = bb_middle - bb_stddev * ta.stdev(close, bb_length_adapted)

// EMAs (usando valores adaptados)
ema_fast = ta.ema(close, ema_fast_adapted)
ema_slow = ta.ema(close, ema_slow_adapted)
ema_mid = ta.ema(close, ema_mid_len)  // No adaptada, pero usada directamente
ema_trend = ta.ema(close, ema_trend_len)  // No adaptada, pero usada directamente

// MACD
[macd_line, macd_signal_line, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)

// ATR y filtros mejorados
atr = ta.atr(14)
vol_sma = ta.sma(volume, volume_length)



// Filtros de confirmación más flexibles
in_session = use_time_filter ? time(timeframe.period, session_hours) > 0 : true
vol_ok = use_volume_filter ? volume > vol_sma * volume_mult : true
vol_filter = use_volatility_filter ? atr > ta.sma(atr, 14) * volatility_mult : true
atr_ok = min_atr_filter ? atr > min_atr_value : true

// Combinar todos los filtros (sin trend_ok para evitar circularidad)
all_filters_ok = in_session and vol_ok and vol_filter and atr_ok

// ========================= SCORING SYSTEM BALANCEADO =========================
// Pesos más balanceados por timeframe
rsi_weight = is_1m ? 2.2 : is_5m ? 2.0 : is_15m ? 1.8 : is_30m ? 1.6 : is_45m ? 1.5 : is_1h ? 1.4 : is_2h ? 1.3 : 1.7
ema_weight = is_1m ? 2.5 : is_5m ? 2.3 : is_15m ? 2.1 : is_30m ? 2.0 : is_45m ? 1.9 : is_1h ? 1.8 : is_2h ? 1.7 : 2.0
bb_weight = is_1m ? 1.8 : is_5m ? 1.6 : is_15m ? 1.4 : is_30m ? 1.3 : is_45m ? 1.2 : is_1h ? 1.1 : is_2h ? 1.0 : 1.3
macd_weight = is_1m ? 1.9 : is_5m ? 1.7 : is_15m ? 1.6 : is_30m ? 1.5 : is_45m ? 1.4 : is_1h ? 1.3 : is_2h ? 1.2 : 1.5

// LONG Score - Mejorado y balanceado
long_score = 0.0
if rsi < 35
    long_score += rsi_weight * 1.0
if rsi < 45 and rsi > rsi[1] and rsi > rsi_ma
    long_score += rsi_weight * 0.7
if ta.crossover(ema_fast, ema_slow)
    long_score += ema_weight * 1.2
if ema_fast > ema_slow and close > ema_fast
    long_score += ema_weight * 0.6
if close < bb_lower
    long_score += bb_weight * 1.0
if close < bb_middle and close[1] < bb_lower
    long_score += bb_weight * 0.8
if macd_hist > 0 and macd_hist > macd_hist[1]
    long_score += macd_weight * 0.8
if ta.crossover(macd_line, macd_signal_line)
    long_score += macd_weight * 1.0
if close > ema_trend and use_trend_filter
    long_score += 0.6
if low < ema_mid and close > ema_mid
    long_score += 0.8
// Condiciones adicionales para balance
if rsi < 40 and close > ema_fast and ema_fast > ema_slow
    long_score += 0.5
if volume > vol_sma * volume_mult * 1.5 and not use_volume_filter
    long_score += 0.4

// SHORT Score - Mejorado y balanceado
short_score = 0.0
if rsi > 65
    short_score += rsi_weight * 1.0
if rsi > 55 and rsi < rsi[1] and rsi < rsi_ma
    short_score += rsi_weight * 0.7
if ta.crossunder(ema_fast, ema_slow)
    short_score += ema_weight * 1.2
if ema_fast < ema_slow and close < ema_fast
    short_score += ema_weight * 0.6
if close > bb_upper
    short_score += bb_weight * 1.0
if close > bb_middle and close[1] > bb_upper
    short_score += bb_weight * 0.8
if macd_hist < 0 and macd_hist < macd_hist[1]
    short_score += macd_weight * 0.8
if ta.crossunder(macd_line, macd_signal_line)
    short_score += macd_weight * 1.0
if close < ema_trend and use_trend_filter
    short_score += 0.6
if high > ema_mid and close < ema_mid
    short_score += 0.8
// Condiciones adicionales para balance
if rsi > 60 and close < ema_fast and ema_fast < ema_slow
    short_score += 0.5
if volume > vol_sma * volume_mult * 1.5 and not use_volume_filter
    short_score += 0.4

// ========================= DOBLE CONFIRMACIÓN =========================
// Variables para tracking de señales previas
var int last_signal_bar = na
var string last_signal_type = ""

// Evitar señales contradictorias
avoid_conflict = false
if require_double_confirmation and not na(last_signal_bar)
    bars_since_signal = bar_index - last_signal_bar
    if bars_since_signal < confirmation_bars
        avoid_conflict := true

// Señales raw con filtros (sin trend filter)
long_signal_raw = long_score >= long_threshold and all_filters_ok
short_signal_raw = short_score >= short_threshold and all_filters_ok

// Aplicar doble confirmación mejorada
prevent_opposite = require_double_confirmation and not na(last_signal_bar) and (bar_index - last_signal_bar) < confirmation_bars

// Señales finales con trend filter aplicado directamente (para evitar circularidad)
long_signal = long_signal_raw and not (prevent_opposite and last_signal_type == "SHORT") and not short_signal_raw and (not use_trend_filter or close > ema_trend)
short_signal = short_signal_raw and not (prevent_opposite and last_signal_type == "LONG") and not long_signal_raw and (not use_trend_filter or close < ema_trend)

// Actualizar tracking
if long_signal
    last_signal_bar := bar_index
    last_signal_type := "LONG"
if short_signal
    last_signal_bar := bar_index
    last_signal_type := "SHORT"

// ========================= SL/TP MANAGEMENT =========================
var float entry_price = na
var float sl_price = na
var float tp_price = na
var string current_position = ""
var int entry_bar = na

if long_signal
    entry_price := close
    sl_price := close - atr * atr_sl_mult
    tp_price := close + atr * atr_tp_mult
    current_position := "LONG"
    entry_bar := bar_index

if short_signal
    entry_price := close
    sl_price := close + atr * atr_sl_mult
    tp_price := close - atr * atr_tp_mult
    current_position := "SHORT"
    entry_bar := bar_index

// Gestión de posiciones mejorada: Cerrar posición si se alcanza SL, TP o señal opuesta
if current_position == "LONG" and (low <= sl_price or high >= tp_price or short_signal)
    current_position := ""
    entry_price := na
    sl_price := na
    tp_price := na

if current_position == "SHORT" and (high >= sl_price or low <= tp_price or long_signal)
    current_position := ""
    entry_price := na
    sl_price := na
    tp_price := na

// ========================= SOPORTES/RESISTENCIAS DINÁMICOS =========================
var array<float> support_levels = array.new_float()
var array<float> resistance_levels = array.new_float()
var array<line> sr_lines = array.new_line()

// Función para contar toques (optimizada con max_bars)
count_touches(level, tolerance, max_bars) =>
    count = 0
    for i = 0 to math.min(max_bars, bar_index)
        if math.abs(close[i] - level) <= tolerance * syminfo.mintick
            count += 1
    count

// Función para verificar si un nivel ya existe
level_exists(levels_array, new_level, min_dist) =>
    exists = false
    if array.size(levels_array) > 0
        for i = 0 to array.size(levels_array) - 1
            if math.abs(array.get(levels_array, i) - new_level) < min_dist * syminfo.mintick
                exists := true
                break
    exists

// Detectar pivots y crear niveles S/R
pivot_high = ta.pivothigh(high, pivot_len, pivot_len)
pivot_low = ta.pivotlow(low, pivot_len, pivot_len)

// Ajuste dinámico de tolerancia
sr_tolerance_dynamic = atr * 0.5 / syminfo.mintick

if not na(pivot_high) and not level_exists(resistance_levels, pivot_high, min_distance_ticks)
    touches = count_touches(pivot_high, sr_tolerance_dynamic, sr_lookback)  // Usando función optimizada y tolerancia dinámica
    if touches >= sr_strength_min
        array.push(resistance_levels, pivot_high)
        if show_sr_lines  // Solo dibujar si está activado
            new_line = line.new(
              x1=bar_index[pivot_len], y1=pivot_high, 
              x2=bar_index, y2=pivot_high,
              extend=extend.right, color=color.new(color.red, 20), width=2)
            array.push(sr_lines, new_line)
        
        // Mantener solo las líneas más fuertes y limpiar memoria
        if array.size(resistance_levels) > max_lines
            array.shift(resistance_levels)
            if array.size(sr_lines) > 0
                old_line = array.shift(sr_lines)
                line.delete(old_line)

if not na(pivot_low) and not level_exists(support_levels, pivot_low, min_distance_ticks)
    touches = count_touches(pivot_low, sr_tolerance_dynamic, sr_lookback)  // Usando función optimizada y tolerancia dinámica
    if touches >= sr_strength_min
        array.push(support_levels, pivot_low)
        if show_sr_lines  // Solo dibujar si está activado
            new_line = line.new(
              x1=bar_index[pivot_len], y1=pivot_low, 
              x2=bar_index, y2=pivot_low,
              extend=extend.right, color=color.new(color.green, 20), width=2)
            array.push(sr_lines, new_line)
        
        if array.size(support_levels) > max_lines
            array.shift(support_levels)
            if array.size(sr_lines) > 0
                old_line = array.shift(sr_lines)
                line.delete(old_line)

// ========================= PLOTS Y VISUALIZACIÓN =========================
// EMAs
plot(ema_fast, 'EMA Rápida', color=color.blue, linewidth=1)
plot(ema_slow, 'EMA Lenta', color=color.red, linewidth=1)
plot(ema_mid, 'EMA Media', color=color.orange, linewidth=2)
plot(ema_trend, 'EMA Tendencia', color=color.purple, linewidth=2)

// Bandas de Bollinger
plot(bb_upper, 'BB Superior', color=color.gray)
plot(bb_middle, 'BB Media', color=color.gray)
plot(bb_lower, 'BB Inferior', color=color.gray)

// Señales
plotshape(show_signals and long_signal, 'Long Signal', shape.triangleup, 
  location.belowbar, color.green, size=size.normal)
plotshape(show_signals and short_signal, 'Short Signal', shape.triangledown, 
  location.abovebar, color.red, size=size.normal)

// SL/TP
plot(sl_price, 'Stop Loss', color=color.red, style=plot.style_circles, linewidth=2)
plot(tp_price, 'Take Profit', color=color.green, style=plot.style_circles, linewidth=2)

// ========================= TABLA COMPACTA ESENCIAL + SL/TP DINÁMICOS =========================
var table info_table = table.new(position.top_right, 2, 10, border_width=1, bgcolor=color.new(color.white, 85))

// Variables persistentes
var string last_entry_time = ""
var float last_entry_price = na
var string last_entry_type = ""
var float last_sl = na
var float last_tp = na

// Actualizar datos cuando hay señal
if long_signal
    last_entry_time := str.tostring(time, "yyyy-MM-dd HH:mm")
    last_entry_price := close
    last_entry_type := "LONG"
    last_sl := sl_price
    last_tp := tp_price

if short_signal
    last_entry_time := str.tostring(time, "yyyy-MM-dd HH:mm")
    last_entry_price := close
    last_entry_type := "SHORT"
    last_sl := sl_price
    last_tp := tp_price

if show_debug_info
    // Fila 0 - Timeframe
    table.cell(info_table, 0, 0, "Timeframe", bgcolor=color.blue, text_color=color.white)
    table.cell(info_table, 1, 0, _tf, bgcolor=color.blue, text_color=color.white)

    // Fila 1 - Long Score
    table.cell(info_table, 0, 1, "Long Score", text_color=color.rgb(30,221,78))
    table.cell(info_table, 1, 1, str.tostring(long_score, "#.##"),
      text_color=long_score >= long_threshold ? color.green : color.rgb(211,215,226))

    // Fila 2 - Short Score
    table.cell(info_table, 0, 2, "Short Score", text_color=color.rgb(212,215,223))
    table.cell(info_table, 1, 2, str.tostring(short_score, "#.##"),
      text_color=short_score >= short_threshold ? color.red : color.rgb(226,228,235))

    // Fila 3 - Umbrales
    table.cell(info_table, 0, 3, "Umbrales", text_color=color.rgb(138,165,240))
    table.cell(info_table, 1, 3, str.tostring(long_threshold, "#.#") + "/" + str.tostring(short_threshold, "#.#"),
      text_color=color.rgb(96,131,228))

    // Fila 4 - Posición actual
    table.cell(info_table, 0, 4, "Posición", text_color=color.rgb(221,18,28))
    table.cell(info_table, 1, 4, current_position == "" ? "—" : current_position,
      text_color=current_position == "LONG" ? color.green : current_position == "SHORT" ? color.red : color.blue)

    // Fila 5 - Filtros
    table.cell(info_table, 0, 5, "Filtros", text_color=color.rgb(133,159,230))
    table.cell(info_table, 1, 5, (vol_ok ? "V✓" : "V✗") + " " + (vol_filter ? "Vol✓" : "Vol✗") + " " + (in_session ? "T✓" : "T✗"),
      text_color=color.blue)

    // Fila 6 - Vol Mult / ATR
    table.cell(info_table, 0, 6, "Vol Mult/ATR", text_color=color.rgb(73,114,224))
    table.cell(info_table, 1, 6, str.tostring(volume_mult, "#.#") + " / " + str.tostring(atr, "#.####"),
      text_color=color.rgb(238,239,243))

    // Fila 7 - Niveles S/R
    int sr_count = array.size(support_levels) + array.size(resistance_levels)
    table.cell(info_table, 0, 7, "S/R detectados", text_color=color.rgb(96,131,228))
    table.cell(info_table, 1, 7, str.tostring(sr_count), text_color=color.rgb(96,131,228))

    // Fila 8 - SL / TP dinámicos
    string sl_text = na(last_sl) ? "—" : "SL " + str.tostring(last_sl, format.mintick)
    string tp_text = na(last_tp) ? "—" : "TP " + str.tostring(last_tp, format.mintick)
    table.cell(info_table, 0, 8, "SL / TP", text_color=color.green)
    table.cell(info_table, 1, 8, sl_text + " / " + tp_text, text_color=color.rgb(59, 231, 6))

    // Fila 9 (última en amarillo) - Precio de entrada
    string last_price_display = na(last_entry_price) ? "—" : (last_entry_type + " @ " + str.tostring(last_entry_price, format.mintick))
    table.cell(info_table, 0, 9, "Precio entrada", bgcolor=color.yellow, text_color=color.black)
    table.cell(info_table, 1, 9, last_price_display, bgcolor=color.yellow, text_color=color.black)




// ========================= ALERTAS =========================
alertcondition(long_signal, 'LONG Signal', 
  'LONG señal en {{ticker}} a {{close}} - SL: {{plot("Stop Loss")}} TP: {{plot("Take Profit")}}')
alertcondition(short_signal, 'SHORT Signal', 
  'SHORT señal en {{ticker}} a {{close}} - SL: {{plot("Stop Loss")}} TP: {{plot("Take Profit")}}')
